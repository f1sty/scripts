#!/usr/bin/elixir --no-halt

defmodule Reminder do
  @moduledoc """
  Reminder every n minutes.
  """
  def loop(sound_file, work_duration, break_duration, is_break) do
    if is_break do
      IO.puts("It's break time, have a nice tea :)")
      Process.send_after(self(), {:alarm, sound_file}, break_duration)
    else
      IO.puts("It's time to get back to work, bro.")
      Process.send_after(self(), {:alarm, sound_file}, work_duration)
    end

    receive do
      {:alarm, sound_file} ->
        play_sound(sound_file)
        loop(sound_file, work_duration, break_duration, not(is_break))
      :cancel ->
        IO.puts("Reminder canceled at #{DateTime.utc_now()} UTC. Goodbye!")
      _ ->
        loop(sound_file, work_duration, break_duration, is_break)
    end
  end

  def cancel(pid), do: send(pid, :cancel)

  def set_reminder(sound_file \\ "~/downloads/bell.wav", work_duration, break_duration) do
    sound_file = Path.expand(sound_file)
    work_duration = :timer.minutes(work_duration)
    break_duration = :timer.minutes(break_duration)

    spawn(__MODULE__, :loop, [sound_file, work_duration, break_duration, false])
  end

  def play_sound(path) do
    {_, 0} = System.cmd("mpv", ["--quiet", path])
  end

  def menu(pid) do
    command = IO.gets("> ") |> String.trim()

    case command do
      "q" ->
        send(pid, :cancel)
        System.halt()
      _ ->
        IO.puts("Unknown command")
    end
    menu(pid)
  end
end

[work_duration, break_duration] = System.argv()

{work_duration, _} = Integer.parse(work_duration)
{break_duration, _} = Integer.parse(break_duration)

reminder = Reminder.set_reminder(work_duration, break_duration)
Reminder.menu(reminder)
